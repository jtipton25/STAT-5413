# Day 11

## Announcements

## Example spatial analysis

```{r, message = FALSE}
library(tidyverse)
library(fields)
library(geoR)
library(STRbook)
library(maps)
library(nlme)
```

## Spatial model fitting

We will use the _NOAA_df_1990_ _data.frame_ from the _STRbook_ package. We will 

```{r}
data("NOAA_df_1990")
## add a factor variable for left_join
NOAA_df_1990$id_factor <- factor(NOAA_df_1990$id)
dat <- NOAA_df_1990 %>%
    subset(year == 1990 & month == 7 & proc == "Tmax") %>%
    group_by(id_factor) %>% 
    summarize(mean_Tmax = mean(z)) #

## add back in the lat/lon variables
dat <- NOAA_df_1990 %>%
    subset(year == 1990 & month == 7 & proc == "Tmax" & day == 1) %>%
    left_join(dat, by = "id_factor") 
```

We can plot the data

```{r}
states <- map_data("state")

dat %>%
    ggplot(aes(x = lon, y = lat, color = mean_Tmax)) +
    geom_point() +
    geom_polygon(data = states, aes(x = long, y = lat, group = group), 
                          colour = "black", fill = NA) +
    scale_color_viridis_c(option = "plasma") +
    ggtitle("Average July max Temperature in 1990")
```

Subset to just the region of interest

```{r}
states <- map_data("state")

dat %>%
    ggplot(aes(x = lon, y = lat, color = mean_Tmax)) +
    geom_point() +
    scale_color_viridis_c(option = "plasma") +
    ggtitle("Average July max Temperature in 1990") +
    geom_polygon(data = states, aes(x = long, y = lat, group = group), 
                 colour = "black", fill = NA, inherit.aes = FALSE) +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)

```


```{r}
dat %>%
    ggplot(aes(x = mean_Tmax)) +
    geom_histogram() +
    ggtitle("Average July max Temperature in 1990")
```

* The histogram looks non-normal. Is this a problem?

### Fit the maximum likelihood estimate using the _geoR_ package

* Fit the maximum likelihood estimate using an intercept only model
) using the _geoR_ package

```{r}
fit <- geoR::likfit(
    data         = dat$mean_Tmax,
    coords       = cbind(dat$lat, dat$lon),
    cov.model    = "exponential",
    ini.cov.pars = c(var(dat$mean_Tmax), 1) 
)

summary(fit)
AIC(fit)
fit$BIC
```

* Plot the estimated spatial correlation function

Model: $\mathbf{y} \sim N(\mu \mathbf{1}, \sigma^2 \mathbf{I} + \tau^2 \mathbf{R}(\phi))$

```{r}
sigma2 <- fit$nugget
tau2   <- fit$sigmasq
phi    <- fit$phi


d   <- seq(0, 150, length.out = 1000)
cov <- ifelse(d == 0, tau2, 0) + tau2 * exp( -  d / phi)
cor <- cov / cov[1]
data.frame(
    d   = d[-1], 
    cov = cov[-1]
) %>%
    ggplot(aes(x = d, y = cov)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cov_nugget = cov[1]), 
               aes(x = d_nugget, y = cov_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated covariance function") +
    ylim(c(0, max(cov)))

data.frame(
    d   = d[-1], 
    cor = cor[-1]
) %>%
    ggplot(aes(x = d, y = cor)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cor_nugget = cor[1]), 
               aes(x = d_nugget, y = cor_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated correlation function") + 
    ylim(c(0, max(cor)))
```

* Fit the model with coefficients

```{r}
fit_coef <- geoR::likfit(
    data         = dat$mean_Tmax,
    trend        = ~ dat$lat + dat$lon,
    coords       = cbind(dat$lat, dat$lon),
    cov.model    = "exponential",
    ini.cov.pars = c(var(dat$mean_Tmax), 1) 
)

summary(fit_coef)
## look at the AIC
AIC(fit)
AIC(fit_coef)

## look at the BIC
fit$BIC
fit_coef$BIC
```

* Which model is better fitting the data?

* Plot the estimated spatial correlation function

Model: $\mathbf{y} \sim N(\mu \mathbf{1}, \sigma^2 \mathbf{I} + \tau^2 \mathbf{R}(\phi))$

```{r}
sigma2 <- fit_coef$nugget
tau2   <- fit_coef$sigmasq
phi    <- fit_coef$phi


d   <- seq(0, 150, length.out = 1000)
cov <- ifelse(d == 0, tau2, 0) + tau2 * exp( -  d / phi)
cor <- cov / cov[1]
data.frame(
    d   = d[-1], 
    cov = cov[-1]
) %>%
    ggplot(aes(x = d, y = cov)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cov_nugget = cov[1]), 
               aes(x = d_nugget, y = cov_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated covariance function") +
    ylim(c(0, max(cov)))

data.frame(
    d   = d[-1], 
    cor = cor[-1]
) %>%
    ggplot(aes(x = d, y = cor)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cor_nugget = cor[1]), 
               aes(x = d_nugget, y = cor_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated correlation function") + 
    ylim(c(0, max(cor)))
```



* Other models are available -- see _?cov.model_ for details

#### Spatial predictions using _geoR_

```{r}
pred_locations <- expand.grid(
  seq(min(dat$lat), max(dat$lat), length.out = 100),
  seq(min(dat$lon), max(dat$lon), length.out = 100)
)
names(pred_locations) <- c("lat", "lon")
pred_locations <- data.frame(pred_locations)
preds <- krige.conv(
  data = dat$mean_Tmax,
  coords       = cbind(dat$lat, dat$lon),
  locations    = cbind(pred_locations$lat, pred_locations$lon),
  krige = krige.control(
    cov.model    = "exponential",
    beta         = fit_coef$beta,
    cov.pars     = fit_coef$cov.pars,
    nugget       = fit_coef$nugget
  )
)

dat_pred <- data.frame(
  preds = preds$predict,
  var   = preds$krige.var,
  lat   = pred_locations$lat,
  lon   = pred_locations$lon
) 
```


```{r, out.width = "49%", fig.show = "hold"}

ggplot(dat_pred, aes(x = lon, y = lat, fill = preds)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Predicted Average July max Temperature in 1990") +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)

ggplot(dat_pred, aes(x = lon, y = lat, fill = var)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Average July max Temperature prediction Variance in 1990")  +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)
```

* What explains the "patchiness" of the variance estimates?


```{r}
ggplot(dat_pred, aes(x = lon, y = lat, fill = var)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Average July max Temperature prediction Variance in 1990") +
  geom_point(data = dat, aes(x = lon, y = lat), inherit.aes = FALSE,
             color = "white", size = 0.6) +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)
```

### Fitting a spatial model using the _nlme_ package

```{r}
fit <- gls(
  mean_Tmax ~ 1,
  data = dat, 
  correlation = corExp(form = ~ lat + lon, nugget = TRUE), 
  method = "ML"
)
summary(fit)
summary(fit)$AIC
summary(fit)$BIC
```

* Plot the estimated covariance/correaltion function

Note: the _gls_ function partitions the variance using a single overall variance $\sigma^2_{gls}$ and a proportion constant $\rho \in (0, 1)$ so that our nugget $sigma^2 = \rho * \sigma^2_{gls}$ and our partial sill $\tau^2 = (1 - \rho) * \sigma^2_{gls}$.

```{r}
## extract the model parameters from the gls fit
phi    <- exp(fit$model[1]$corStruct[1])
rho    <- 1 / (1 + exp(-fit$model[1]$corStruct[2])) 

sigma2 <- fit$sigma^2 * (rho)
tau2   <- fit$sigma^2 * (1-rho)


d   <- seq(0, 150, length.out = 1000)
cov <- ifelse(d == 0, tau2, 0) + tau2 * exp( -  d / phi)
cor <- cov / cov[1]
data.frame(
    d   = d[-1], 
    cov = cov[-1]
) %>%
    ggplot(aes(x = d, y = cov)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cov_nugget = cov[1]), 
               aes(x = d_nugget, y = cov_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated covariance function") +
    ylim(c(0, max(cov)))

data.frame(
    d   = d[-1], 
    cor = cor[-1]
) %>%
    ggplot(aes(x = d, y = cor)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cor_nugget = cor[1]), 
               aes(x = d_nugget, y = cor_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated correlation function") + 
    ylim(c(0, max(cor)))
```


We can also fit this model using covariates


```{r}
fit_coef <- gls(
  mean_Tmax ~ lat + lon,
  data = dat, 
  correlation = corExp(form = ~ lat + lon, nugget = TRUE), 
  method = "ML"
)
summary(fit_coef)

summary(fit)$AIC
summary(fit_coef)$AIC

summary(fit)$BIC
summary(fit_coef)$BIC
```

* Plot the estimated covariance/correaltion function

Note: the _gls_ function partitions the variance using a single overall variance $\sigma^2_{gls}$ and a proportion constant $\rho \in (0, 1)$ so that our nugget $sigma^2 = \rho * \sigma^2_{gls}$ and our partial sill $\tau^2 = (1 - \rho) * \sigma^2_{gls}$.

```{r}
## extract the model parameters from the gls fit
phi    <- exp(fit_coef$model[1]$corStruct[1])
rho    <- 1 / (1 + exp(-fit_coef$model[1]$corStruct[2])) 

sigma2 <- fit_coef$sigma^2 * (rho)
tau2   <- fit_coef$sigma^2 * (1-rho)


d   <- seq(0, 150, length.out = 1000)
cov <- ifelse(d == 0, tau2, 0) + tau2 * exp( -  d / phi)
cor <- cov / cov[1]
data.frame(
    d   = d[-1], 
    cov = cov[-1]
) %>%
    ggplot(aes(x = d, y = cov)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cov_nugget = cov[1]), 
               aes(x = d_nugget, y = cov_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated covariance function") +
    ylim(c(0, max(cov)))

data.frame(
    d   = d[-1], 
    cor = cor[-1]
) %>%
    ggplot(aes(x = d, y = cor)) +
    geom_line() +
    geom_point(data = data.frame(d_nugget = d[1], cor_nugget = cor[1]), 
               aes(x = d_nugget, y = cor_nugget), inherit.aes = FALSE) +
    ggtitle("Estimated correlation function") + 
    ylim(c(0, max(cor)))
```



* Other correlation structures avaiable with _?corClasses_

#### Spatial predictions using _nlme_

```{r}
pred_locations <- expand.grid(
  seq(min(dat$lat), max(dat$lat), length.out = 100),
  seq(min(dat$lon), max(dat$lon), length.out = 100)
)
names(pred_locations) <- c("lat", "lon")
pred_locations <- data.frame(pred_locations)

preds <- predict(
  fit_coef, 
  newdata = pred_locations
)

dat_pred <- data.frame(
  preds = preds,
  lat   = pred_locations$lat,
  lon   = pred_locations$lon
) 

ggplot(dat_pred, aes(x = lon, y = lat, fill = preds)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Predicted Average July max Temperature in 1990") +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)
```


### model fitting with _autokrige_ function

```{r}
library(automap)
dat_points <- SpatialPointsDataFrame(
  coords = cbind(dat$lon, dat$lat),
  data  = data.frame(
    mean_Tmax = dat$mean_Tmax,
    lat = dat$lat,
    lon = dat$lon
  )
)
pred_points <- SpatialPointsDataFrame(
  coords = cbind(dat_pred$lon, dat_pred$lat),
  data  = data.frame(
    lat = dat_pred$lat,
    lon = dat_pred$lon
  )
)
  
fit <- autoKrige(
  mean_Tmax ~ 1,
  input_data = dat_points, 
  new_data = pred_points
)
summary(fit)
```

```{r}
plot(fit)
```

```{r}
fit_coef <- autoKrige(
  mean_Tmax ~ lat + lon,
  input_data = dat_points, 
  new_data = pred_points
)
summary(fit_coef)
```


```{r}
plot(fit_coef)
```

```{r, out.width = "49%", fig.show = "hold"}
dat_pred <- data.frame(
  preds = fit_coef$krige_output@data$var1.pred,
  var   = fit_coef$krige_output@data$var1.var,
  lat   = pred_locations$lat,
  lon   = pred_locations$lon
) 
ggplot(dat_pred, aes(x = lon, y = lat, fill = preds)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Predicted Average July max Temperature in 1990") +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)


ggplot(dat_pred, aes(x = lon, y = lat, fill = var)) +
  geom_raster() +
  geom_polygon(data = states, aes(x = long, y = lat, group = group), 
               colour = "black", fill = NA) +
  scale_fill_viridis_c(option = "plasma") +
  ggtitle("Average July max Temperature prediction Variance in 1990")  +
  coord_fixed(xlim = range(dat$lon), ylim = range(dat$lat), ratio = 1.3)
```